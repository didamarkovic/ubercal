""" For functions to handle the files.

	09/06/2016, KMarkovic
"""

import subprocess as sp
import os.path as op
import datetime

HOME = op.dirname(op.dirname(__file__))

# A class that contains the Git environment at the time of it's initialisation.
# Currently it uses the subprocess module to speak to Git through the system.
#	Ideally some day it would use the GitPython module.
class GitEnv(object):

	# Some day could pass the directory containing the .git/ folder as a possible input to __init__.
	# Could find this by searching for it in each parent directory and keep cd .. -ing until you find it.
	def __init__(self, startwith=''):
		self.printstart = startwith
		self.git_dir = op.join(HOME, '.git')
		if op.exists(self.git_dir):
			self.isgit = True
			self.hash, self.author, self.date = [str(s) for s in self.get_commit()]
			self.url = str(self.get_remote())
			self.branch = str(self.get_branch())
			self.repo = str(self.get_repo())
		else:
			self.isgit = False
			self.author = 'Dida Markovic'
			self.date = str(datetime.date.today())
			self.repo = HOME

	# Also, should have an if that gives out the name of the parent folder + the
	# date and time in the case that it is NOT A GIT REPO!

	def __str__(self):
		startline = self.printstart
		if self.isgit:
			as_string = startline + "This was generated by code from the Git repository at:"
			as_string += "\n" + startline + "\t " + self.url + ","
			as_string += "\n" + startline + "\t on the " + self.branch + " branch,"
			as_string += "\n" + startline + "\t with commit: " + self.hash
			as_string += "\n" + startline + "\t\t from " + self.date + ", "
			as_string += "\n" + startline + "\t\t by " + self.author + "."
		else:
			as_string = startline + "This was generated by code in:"
			as_string += "\n" + startline + "\t " + self.repo + ","
			as_string += "\n" + startline + "\t\t on " + self.date + ", "
			as_string += "\n" + startline + "\t\t by " + self.author + "."
		return as_string

	def set_print(self, startline):
		self.printstart = startline

	def get_git_cmd(self, args=[]):
		cmd = ['git']
		if self.git_dir != None:
			cmd.append('--git-dir')
			cmd.append(self.git_dir)
		for one in args:
			cmd.append(one)

		return cmd

	def get_hash(self, nochar=7, sep=''):
		return sep+self.hash[0:nochar]+sep

	# Get the hash, author and date of the most recent commit of the current repo.
	def get_commit(self):
		cmd = sp.Popen(self.get_git_cmd(['log', '-n','1']), stdout=sp.PIPE)
		cmd_out, cmd_err = cmd.communicate()
		newlist=[]
		for entry in cmd_out.strip().split('\n'):
			if entry=='': continue
			entry = entry.split(' ')
			# This is a hack, should use a dict so can be sure what we are reading in:
			if 'commit' in entry[0] or 'Author' in entry[0] or 'Date' in entry[0]:
				newlist.append(' '.join(entry[1:]).strip())
		return newlist

	# At the moment this only gives the first url in what git returns.
	# Eventually it'd be nice if you could get the origin url, the fetch...
	def get_remote(self):
		cmd = sp.Popen(self.get_git_cmd(['remote', '-v']), stdout=sp.PIPE)
		cmd_out, cmd_err = cmd.communicate()
		if bool(cmd_out):
			try:
				return cmd_out.strip().split('https://')[1].split(' ')[0]
			except IndexError:
				ssh_url = cmd_out.strip().split('git@')[1].split(' ')[0]
				return ssh_url.replace(':','/')
		else:
			return None

	def get_branch(self):
		cmd = sp.Popen(self.get_git_cmd(['branch']), stdout=sp.PIPE)
		cmd_out, cmd_err = cmd.communicate()
		branches = cmd_out.strip().splitlines()
		for branch in branches:
			if '*' in branch:
				return branch.replace('*','').strip()

	def get_repo(self):
		cmd = sp.Popen(self.get_git_cmd(['rev-parse','--show-toplevel']), stdout=sp.PIPE)
		cmd_out, cmd_err = cmd.communicate()
		return cmd_out.strip().split('/')[-1]
